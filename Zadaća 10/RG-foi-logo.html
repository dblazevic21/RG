<!doctype html>
<html lang="hr">
<head>
  <meta charset="UTF-8" />
  <title>FOI logo - WebGL2 animacija</title>
  <title>PREPORUÄŒUJEM NE ZOOMIRATI, slow downa browser dosta</title>
  <style>
    body { margin: 0; background:#111; color:#fff; font-family: system-ui, Arial; }
    .wrap { display:flex; flex-direction:column; align-items:center; gap:10px; padding:16px; }
    canvas { border:6px solid #000; background:#000; }
  </style>

  <script src="./RG-WebGL.js"></script>

  <script>
    window.onload = WebGLaplikacija;

    function WebGLaplikacija() {
      const canvas = document.getElementById("slika1");
      const gl = canvas.getContext("webgl2");
      if (!gl) { alert("WebGL2 nije dostupan!"); return; }

      const prog = pripremiGPUprogram(gl, "vertex-shader", "fragment-shader");
      gl.useProgram(prog);

      const vrhovi = new Float32Array([
        -1, -1,
         1, -1,
         1,  1,
        -1,  1
      ]);

      prog.a_vrhXY = gl.getAttribLocation(prog, "a_vrhXY");
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, vrhovi, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(prog.a_vrhXY);
      gl.vertexAttribPointer(prog.a_vrhXY, 2, gl.FLOAT, false, 0, 0);

      const u_time = gl.getUniformLocation(prog, "u_time");
      const u_res  = gl.getUniformLocation(prog, "u_resolution");

      gl.clearColor(0, 0, 0, 1);

      function resizeCanvasToDisplaySize() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const displayW = Math.floor(canvas.clientWidth * dpr);
        const displayH = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== displayW || canvas.height !== displayH) {
          canvas.width = displayW;
          canvas.height = displayH;
        }
      }

      const t0 = performance.now();
      function draw() {
        resizeCanvasToDisplaySize();
        gl.viewport(0, 0, canvas.width, canvas.height);

        const t = (performance.now() - t0) * 0.001;
        gl.uniform1f(u_time, t);
        gl.uniform2f(u_res, canvas.width, canvas.height);

        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);
    }
  </script>

  <script id="vertex-shader" type="x-shader/x-vertex">
    #version 300 es
    in vec2 a_vrhXY;
    out vec2 v_uv;

    void main() {
      gl_Position = vec4(a_vrhXY, 0.0, 1.0);
      v_uv = a_vrhXY * 0.5 + 0.5;
    }
  </script>

<script id="fragment-shader" type="x-shader/x-fragment">
#version 300 es
precision highp float;

in vec2 v_uv;
out vec4 bojaPiksela;

uniform float u_time;
uniform vec2  u_resolution;

float hash(vec2 p){
  p = fract(p * vec2(123.34, 456.21));
  p += dot(p, p + 45.32);
  return fract(p.x * p.y);
}

float sdBox(vec2 p, vec2 b){
  vec2 d = abs(p) - b;
  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

float sdCircle(vec2 p, float r){
  return length(p) - r;
}

float fillMask(float d, float aa){
  return 1.0 - smoothstep(-aa, aa, d);
}

float sdEllipseRing(vec2 p, vec2 stretch, float r, float t){
  vec2 q = p / stretch;
  float dOuter = length(q) - r;
  float dInner = -(length(q) - (r - t));
  return max(dOuter, dInner);
}

float sdHalfPlaneX(vec2 p, float x0){
  return -(p.x - x0);
}

float sdHalfPlaneY(vec2 p, float y0){
  return -(p.y - y0);
}

struct LogoResult {
  float d;
  float oFillD;
};

LogoResult logoFOI(vec2 p)
{
  float F_SHIFT_Y = 0.1;
  vec2 pf = p + vec2(0.35, F_SHIFT_Y);

  float stemW = 0.060;
  float stemH = 0.150;
  float dStem = sdBox(pf - vec2(0.0, 0.0), vec2(stemW, stemH));

  float barW = 0.220;
  float barH = 0.050;
  float barY = stemH;
  float dBarTop = sdBox(pf - vec2(0.0, barY), vec2(barW, barH));

  float dT = min(dStem, dBarTop);

  vec2 pTop = pf - vec2(0.00, barY);
  float arcR = 0.3;
  float arcT = 0.10;
  vec2 stretch = vec2(1.15, 1.05);

  float ARC_SHIFT_X = -0.29;
  float ARC_SHIFT_Y = -0.05;

  vec2 arcP = pTop + vec2(ARC_SHIFT_X, ARC_SHIFT_Y);
  arcP.x = -arcP.x;

  float dArc = sdEllipseRing(arcP, stretch, arcR, arcT);
  dArc = max(dArc, sdHalfPlaneY(arcP, -0.02));
  dArc = max(dArc, sdHalfPlaneX(arcP, -stemW*0.10));

  float dF = min(dT, dArc);

  float O_SHIFT_Y = 0.06;
  vec2 po = (p - vec2(0.08, 0.00)) + vec2(0.0, O_SHIFT_Y);

  float ro = 0.15;
  float thick = 0.072;
  float doOuter = sdCircle(po, ro);
  float doInner = -sdCircle(po, ro - thick);
  float dO = max(doOuter, doInner);

  float dOFill = sdCircle(po, ro - thick - 0.0);

  float I_SHIFT_Y = 0.1;
  vec2 pi = (p - vec2(0.35, 0.0)) + vec2(0.0, I_SHIFT_Y);

  float dIstem = sdBox(pi - vec2(0.05, 0.05), vec2(0.060, 0.20));
  float dIdot  = sdCircle(pi - vec2(0.05, 0.4), 0.075);
  float dI = min(dIstem, dIdot);

  float d = min(min(dF, dO), dI);

  LogoResult r;
  r.d = d;
  r.oFillD = dOFill;
  return r;
}

void main(){
  float aspect = u_resolution.x / u_resolution.y;

  vec2 p = (v_uv - 0.5) * vec2(aspect, 1.0);
  float rr = length(p);

  vec3 c1 = vec3(0.03, 0.02, 0.05);
  vec3 c2 = vec3(0.18, 0.03, 0.09);
  vec3 c3 = vec3(0.55, 0.05, 0.22);

  float sweep = 0.5 + 0.5*sin(u_time*0.25);
  float g = smoothstep(-0.6, 0.8, p.x + 0.35*p.y + 0.15*sweep);
  vec3 bg = mix(mix(c1, c2, g), c3, 0.35*g);

  float vign = smoothstep(1.1, 0.25, rr);
  bg *= (0.60 + 0.65*vign);

  bg += (hash(v_uv*u_resolution + u_time) - 0.5) * 0.010;

  float scaleLogo = 1.70;
  vec2 lp = p * scaleLogo;

  float ax = 0.18*sin(u_time*0.9);
  float ay = 0.28*sin(u_time*0.7);
  float ca = cos(ax), sa = sin(ax);
  float cb = cos(ay), sb = sin(ay);

  vec3 P = vec3(lp, 0.0);
  P = vec3(P.x, ca*P.y - sa*P.z, sa*P.y + ca*P.z);
  P = vec3(cb*P.x + sb*P.z, P.y, -sb*P.x + cb*P.z);

  float persp = 0.90;
  vec2 lpp = P.xy / (1.0 + persp*(P.z + 0.12));

  LogoResult LR = logoFOI(lpp);

  float aa = 2.0 / min(u_resolution.x, u_resolution.y) * scaleLogo;
  float mask = fillMask(LR.d, aa);

  float e = aa * 1.8;
  float dL = logoFOI(lpp + vec2(-e, 0.0)).d;
  float dR = logoFOI(lpp + vec2( e, 0.0)).d;
  float dD = logoFOI(lpp + vec2(0.0,-e)).d;
  float dU = logoFOI(lpp + vec2(0.0, e)).d;

  vec2 grad = vec2(dR - dL, dU - dD);
  float bumpStrength = 3.0;
  vec3 N = normalize(vec3(-grad*bumpStrength, 1.0));

  N = vec3(N.x, ca*N.y - sa*N.z, sa*N.y + ca*N.z);
  N = vec3(cb*N.x + sb*N.z, N.y, -sb*N.x + cb*N.z);

  vec3 L = normalize(vec3(0.55*cos(u_time*0.8), 0.55, 0.65*sin(u_time*0.8) + 0.85));
  vec3 V = normalize(vec3(0.0, 0.0, 1.0));
  vec3 H = normalize(L + V);

  float diff = max(dot(N, L), 0.0);
  float spec = pow(max(dot(N, H), 0.0), 72.0);

  vec3 foiRed   = vec3(0.85, 0.05, 0.25);
  vec3 warmFill = vec3(0.98, 0.72, 0.18);

  float oFill = fillMask(LR.oFillD, aa);

  vec2 shDir = normalize(vec2(-L.x, -L.y));
  float px = 1.0 / min(u_resolution.x, u_resolution.y);
  vec2 shOff = shDir * (1.8 * px * scaleLogo);
  float shadow = fillMask(logoFOI(lpp + shOff*3.0).d, aa) * (1.0 - mask);

  float edge = length(grad);
  float glow = smoothstep(0.02, 0.15, edge) * mask;

  float tt = u_time * 0.75;
  float stripe = 1.0 - smoothstep(0.0, 0.06, abs((v_uv.x - v_uv.y*0.22) - fract(tt)));
  stripe *= mask;

  vec3 col = bg;

  col = mix(col, col * 0.55, shadow);
  col += foiRed * glow * 1.15;

  vec3 logoCol = foiRed * (0.28 + 1.10*diff) + vec3(1.0)*spec*0.85;
  vec3 fillCol = warmFill * (0.35 + 1.00*diff) + vec3(1.0)*spec*0.30;

  col = mix(col, logoCol, mask);
  col = mix(col, fillCol, oFill);

  col += vec3(1.0) * stripe * 0.40;

  bojaPiksela = vec4(col, 1.0);
}
</script>

</head>

<body>
  <div class="wrap">
    <h1 style="margin:0;">FOI logo (WebGL2 animacija)</h1>
    <canvas id="slika1" width="1000" height="650"></canvas>
  </div>
</body>
</html>
